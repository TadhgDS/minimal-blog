{"title":"A review of three debugging books","mainText":"When I started in my first role as a software developer, I quickly realised that I was lacking in ability when it came to debugging issues and assessing defects. The defects that took more experienced guys on my team a few minutes to pin-point, took me several hours or worse, I couldn't find at all.\r\nI had trouble interpreting the stack trace, didn't take the time to patiently step through the sequence of steps and instead, I would scatter print statements throughout the code hoping to get some glimpse of what might be going on, taking successive stabs at a solution without ever really understanding what was going wrong.\r\n\r\nSeeing co-workers home in on root causes enough times convinced me that there must be a skill to what previously seemed like black magic. I bought three books on the topic, which I will describe and review briefly and then give my assessment of the entire process at the end. \r\n\r\n\r\nFrom wikipedia:\r\n> Debugging is the process of finding and resolving of defects that prevent correct operation of computer software or a system.\r\n\r\n### Is it a learnable skill or the result of experience?\r\n\r\nSome people will say that debugging can't be learned or thought and is acquired exclusively through experience. \r\nSome reasons why this might seem true:\r\n - Bugs/Defects manifest in so many different ways, that techniques applied to defect #1 might have no application regarding defect #2\r\n - Your ability to debug effeciently increases significantly with your familiarity with the system\r\n\r\n\r\n I don't believe this is true. Most leaps in my ability came from seeing how another developer leveraged a particular tool, ie. a piece of information that could easily be explained to somebody else and not some explainable *intuition*.\r\n\r\n\r\n### Are there things that can't be learned from a book?\r\nObviously, there are some elements of debugging that can't be conveyed in a book. For example, as you get more familiar with a project and learn the idiosyncracies, it becomes easier to detect root causes of defects. You learn to quickly rule out large portions of the code as unlikely factors.\r\n\r\n\r\n### Is this a worthwhile endevour ?\r\n{{1}}According to one study, reworking defects in requirements, design, and code consumes 40-50% of the total cost of software development[1].  \r\n\r\n\r\nIf it's going to cost that much time, it's probably worth it. Other than that - bug fixing is a great opportunity to dive deep and learn specifics of a particular part of a project.\r\nIt forces you to stop taking things for granted and verify all your assumptions, and ultimately makes you a better developer.\r\n\r\n\r\n### DEBUGGING The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems\r\nby David J. Agans\r\n\r\nWritten from the perspective of an electronic engineer, the bugs and stories discussed throughout the book tend to be hardware related issues. Nonetheless, the author's message and the processes he puts forward transcend the software/hardware distinction. \r\n\r\nThe author puts forward the following 9 rules for rigorous debugging and dedicates a chapter to each of the rules where it is discussed in detail. He tells multiple 'war stories' describing some real event that shows the significance of the rule which can help to understand where it applies in real projects.\r\n\r\nRules:\r\n\tMake it fail\r\n\tQuick thinking and look\r\n\tDivide and conquer\r\n\tChange one thing at a time.\r\n\tKeep an audit trail.\r\n\tCheck the plug.\r\n\tGet a fresh view.\r\n\tIf you didn't fix it, it ain't fixed.\r\n\r\nThis is a great book.\r\nI could only fully appreciate it after I had read the other 2 books.\r\n\r\nInstead of focusing on specific techniques, it focuses on giving you mantras/tenets to follow.\r\nThey are intentionally vague and I understand now that this is the best way to teach better debugging. The variation when it comes to defects means that trying to teach techniques often isn't that useful unless you face a defect for which that specific technique is applicable. This can be and usually is quite unlikely with each defect requiring a different approach and solution.\r\n\r\nThis book tries to show the reader a new way of thinking and interpreting defects which I believe to be a much more rewarding concept for junior developers.\r\n\r\nThe Quit Thinking and Look chapter really resonated with me at the time of reading. Until then, I typically ran into defects and immediately jumped to conclusions about their source. Patiently stepping through the code and paying attention to what is *actually* happening rather than what you assume is happening will often present to you the causes on a plate.\r\n\r\n\r\n\r\n### Debug It!: Find, Repair, and Prevent Bugs in Your Code\r\nby Paul Butcher\r\n\r\nThe book is divided into three sections, section 1 being The Heart of The Problem which covers both finding and fixing defects.\r\nThe opening chapter,'A Method in the Madness' tries to articulate at a high level what constitues good debugging. It introduces core topics like the Empirical approach and defines a Core Debugging Process as one consisting of the following phases:\r\n\t\tReproduce\r\n\t\t\t- Find a way to reliably and conveniently reproduce the problem on demand\r\n\t\tDiagnose\r\n\t\t \t- Construct Hypotheses, and test them by performing experiments until you are confident that you have identified the underlying cause of the bug.\r\n\t\t Fix \r\n\t\t \t- Design and implement changes that fix the problem, avoid introducing regressions, and maintain or improve the overall quality of the software.\r\n\t\t Reflect\r\n\t\t \t- Learn the lessons of the bug. Where did things go wrong? Are there any other examples of the same problem that will also need fixing?\r\n\t\t \tWhat can you do to ensure that the same problem doesn't happen again?\r\nSection 2, titled 'The Bigger Picture', discusses the soft aspects of defect management, such as using a defect database, engaging with users and support staff. It also focuses on the attitude towards bugs on a project, stating that defects should take high priority and outlines a few methods for cleaning up a project that has attained an excess of bugs.\r\n\r\nSection 3, Debug-Fu is a mix of special cases(eg. concurrency or performance bugs), anti-patterns and a discussion of the ideal debugging environment which touts the benefits of continuous integration builds and automated testing.\r\n\r\nThe special cases are particularly insightful, for example this excerpt on non deterministic bugs.\r\n\r\n{{code}}\r\n \"So, where does this nondeterminism come from? Well, it certainly isn't cosmic rays flipping bits at random (no matter how many old programmers' tales you hear). Nondeterminism can have only a few causes:\r\n\t- Starting from an unpredictable initial state\r\n\t- Interaction with external systems\r\n\t- Deliberate randomness\r\n\t- Multithreading\"\r\n\r\n{{/code}}\r\n\r\nand this section on concurrency related defects:\r\n\r\n{{code}}\r\n\"You might launch a number of threads at approximately the same time and find that if their initialization code runs simultaneously, then you can end up with prioblems. An obvious , but incorrect fix would be to stagger launching the threads on the assumption that by the time the second thread is starting, the first will have finished its initialization.\r\n\r\n\tThe problem with any fix of this nature is that if a window isn't completely closed, sooner or later your software __will__ fall into it. Except that now it will do so only underunusual circumstances (perhaps when the system is heavily loaded and running more slowly than normal). All you've managed to do is make it even harder to reproduce and track down the next time.\"\r\n{{/code}}\r\n\r\n\r\n### Why Programs Fail: A Guide to Systematic Debugging\r\nby Andreas Zeller\r\n\r\nI was interested in this book for two reasons:\r\n \t1. I was familiar with Andreas Zeller from a Udacity course on Debugging. I had watched a few lessons of this course where he was funny, kept it interesting and I had hoped the book would be similar. He also taught a course on debugging at the university of which he was a faculty member.\r\n\r\n \t2. It appeared to be the definitive book on debugging and promised to offer a systematic guide to debugging, which was exactly what I was looking for.\r\n\r\nWhat I liked about the book was that it is exhaustive. The author probably discusses every debugging technique in existence within the pages of this book. He even delves into the use of memory profiling tools such as Valgrind, whereas the other two books stay clear of this level of detail.\r\n\r\nHowever, the caveat to this is that the balance is pretty bad. There are large portions of this book dedicated to techniques that you will more than likely never use or (potentially) even encounter throughout your career. Much of this is the author's own research, to which a lot of time is spent examing, as well as tools he has developed to aid the use of these techniques.\r\n\r\nI feel like these parts of the book, although relevant, fall more within the realm of \"an expos√© on the authors research\" than \"a systematic guide to debugging\". \r\n\r\nI feel like book 1 and book 2 were the most useful to me. Why Programs Fail provided a nice overview of all the tools and techniques aimed at finding and fixing defects, but it was Debug It! that gave me practical and relevant examples of how the techniques can be applied. Most valuable was DEBUGGING The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems, which provides a mentality for approaching defects that is grounded in careful and patient examination and will ultimately produce results and save time.\r\n","submitDate":1477746412173,"editDate":"","graphs":"","sn1":"(Boehm, Barry W. 1987. \"Improving Software Productivity.\" IEEE Computer, September: 43-57.)","sn2":"sn2","sn3":"sn3","sn4":"sn4","sn5":"sn5"}